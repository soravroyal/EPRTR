//
// Core.cs
//
// This file was generated by MapForce 2008r2sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//

using System;
using Altova.Types;

namespace Altova.Functions
{
	public interface ISequenceTarget
	{
		void Add(string o);
		void Add(int o);
		void Add(uint o);
		void Add(long o);
		void Add(ulong o);
		void Add(byte[] o);
		void Add(decimal o);
		void Add(double o);
		void Add(object o);
	}
	

	public class Core
	{
		public abstract class NumericalSequenceTarget : ISequenceTarget
		{
			public void Add(string o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(int o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(uint o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(long o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(ulong o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(byte[] o) { throw new Altova.Types.ConversionException("Cannot convert binary to decimal."); }
			public abstract void Add(decimal o);
			public void Add(double o) { Add(Altova.CoreTypes.CastToDecimal(o)); }
			public void Add(object o) { if (o != null) Add(Altova.CoreTypes.CastToDecimal(o)); }
		};

		public class Avg : NumericalSequenceTarget
		{
			decimal sum = 0.0m;
			int count = 0;

			public override void Add(decimal o) 
			{
				sum += o;
				count += 1;
			}

			public decimal Read() { return sum / count; }
		}

		public class Sum : NumericalSequenceTarget
		{
			decimal sum = 0.0m;

			public override void Add(decimal o) 
			{
				sum += o;
			}

			public decimal Read() { return sum; }
		}

		public class Count : ISequenceTarget
		{
			int count = 0;

			public void Add(object o) { if (o != null) count += 1; }
			public void Add(decimal d) { count += 1; }
			public void Add(int d) { count += 1; }
			public void Add(uint d) { count += 1; }
			public void Add(long d) { count += 1; }
			public void Add(ulong d) { count += 1; }
			public void Add(double d) { count += 1; }
			public void Add(byte[] d) { count += 1; }
			public void Add(string d) { count += 1; }

			public int Read() { return count; }
		}

		public class Max : NumericalSequenceTarget
		{
			decimal maxValue;
			bool first = true;

			public override void Add(decimal o)
			{
				if (first)
				{
					maxValue = o;
					first = false;
				}
				else
					maxValue = Math.Max(maxValue, o);
			}

			public decimal Read() { return maxValue; }
		}
		
		public class Min : NumericalSequenceTarget
		{
			decimal minValue;
			bool first = true;

			public override void Add(decimal o)
			{
				if (first)
				{
					minValue = o;
					first = false;
				}
				else
					minValue = Math.Min(minValue, o);
			}

			public decimal Read() { return minValue; }
		}

		public class StringJoin : ISequenceTarget
		{
			System.Text.StringBuilder builder = new System.Text.StringBuilder();
			string delimiter;
			bool first = true;

			public StringJoin(string delimiter) { this.delimiter = delimiter; }

			public void Add(string o)
			{
				if (first)
					first = false;
				else
					builder.Append(delimiter);
				builder.Append(o);
			}

			public void Add(decimal o) { Add(Altova.CoreTypes.CastToString(o)); }
			public void Add(int o) { Add(Altova.CoreTypes.CastToString(o)); }
			public void Add(uint o) { Add(Altova.CoreTypes.CastToString(o)); }
			public void Add(long o) { Add(Altova.CoreTypes.CastToString(o)); }
			public void Add(ulong o) { Add(Altova.CoreTypes.CastToString(o)); }
			public void Add(double o) { Add(Altova.CoreTypes.CastToString(o)); }
			public void Add(byte[] o) { Add(Altova.CoreTypes.CastToString(o)); }
			public void Add(object o) { if (o != null) Add(Altova.CoreTypes.CastToString(o)); }

			public string Read() { return builder.ToString(); }

		};

		// logical functions
		public static bool LogicalNot(bool b) { return !b; }
		public static bool LogicalOr(bool l, bool r) { return l | r; }
		public static bool LogicalAnd(bool l, bool r) { return l & r; }	

		// comparison functions
		public static  bool Equal(bool a, bool b) { return a == b; }
		public static  bool Equal(int a, int b) { return a == b; }
		public static  bool Equal(uint a, uint b) { return a == b; }
		public static  bool Equal(long a, long b) { return a == b; }
		public static  bool Equal(ulong a, ulong b) { return a == b; }
		public static  bool Equal(double a, double b) { return a == b; }
		public static  bool Equal(string a,  string b) { return a == b; }
		public static  bool Equal(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a == b; }
		public static  bool Equal(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks == b.Value.Ticks; }
		public static bool Equal(decimal a, decimal b) { return a == b; }

		public static  bool Greater(bool a, bool b) { return a & !b; }
		public static  bool Greater(int a, int b) { return a > b; }
		public static  bool Greater(uint a, uint b) { return a > b; }
		public static  bool Greater(long a, long b) { return a > b; }
		public static  bool Greater(ulong a, ulong b) { return a > b; }
		public static  bool Greater(double a, double b) { return a > b; }
		public static  bool Greater(string a,  string b) { return a.CompareTo(b) > 0; }
		public static  bool Greater(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a > b; }
		public static  bool Greater(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks > b.Value.Ticks; }
		public static bool Greater(decimal a, decimal b) { return a > b; }

		public static  bool Less(bool a, bool b) { return !a & b; }
		public static  bool Less(int a, int b) { return a < b; }
		public static  bool Less(uint a, uint b) { return a < b; }
		public static  bool Less(long a, long b) { return a < b; }
		public static  bool Less(ulong a, ulong b) { return a < b; }
		public static  bool Less(double a, double b) { return a < b; }
		public static  bool Less(string a,  string b) { return a.CompareTo(b) < 0; }
		public static  bool Less(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a < b; }
		public static  bool Less(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks < b.Value.Ticks; }
		public static bool Less(decimal a, decimal b) { return a < b; }

		public static  bool EqualOrGreater(bool a, bool b) { return !b | a; }
		public static  bool EqualOrGreater(int a, int b) { return a >= b; }
		public static  bool EqualOrGreater(uint a, uint b) { return a >= b; }
		public static  bool EqualOrGreater(long a, long b) { return a >= b; }
		public static  bool EqualOrGreater(ulong a, ulong b) { return a >= b; }
		public static  bool EqualOrGreater(double a, double b) { return a >= b; }
		public static  bool EqualOrGreater(string a,  string b) { return a.CompareTo(b) >= 0; }
		public static  bool EqualOrGreater(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a >= b; }
		public static  bool EqualOrGreater(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks >= b.Value.Ticks; }
		public static bool EqualOrGreater(decimal a, decimal b) { return a >= b; }

		public static  bool EqualOrLess(bool a, bool b) { return !a | b; }
		public static  bool EqualOrLess(int a, int b) { return a <= b; }
		public static  bool EqualOrLess(uint a, uint b) { return a <= b; }
		public static  bool EqualOrLess(long a, long b) { return a <= b; }
		public static  bool EqualOrLess(ulong a, ulong b) { return a <= b; }
		public static  bool EqualOrLess(double a, double b) { return a <= b; }
		public static  bool EqualOrLess(string a,  string b) { return a.CompareTo(b) <= 0; }
		public static  bool EqualOrLess(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a <= b; }
		public static  bool EqualOrLess(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks <= b.Value.Ticks; }
		public static bool EqualOrLess(decimal a, decimal b) { return a <= b; }

		public static  bool NotEqual(bool a, bool b) { return a != b; }
		public static  bool NotEqual(int a, int b) { return a != b; }
		public static  bool NotEqual(uint a, uint b) { return a != b; }
		public static  bool NotEqual(long a, long b) { return a != b; }
		public static  bool NotEqual(ulong a, ulong b) { return a != b; }
		public static  bool NotEqual(double a, double b) { return a != b; }
		public static  bool NotEqual(string a,  string b) { return a != b; }
		public static  bool NotEqual(Altova.Types.DateTime a, Altova.Types.DateTime b) { return a != b; }
		public static  bool NotEqual(Altova.Types.Duration a, Altova.Types.Duration b) { return a.Value.Ticks != b.Value.Ticks; }
		public static bool NotEqual(decimal a, decimal b) { return a != b; }

		// Mathematical functions
		public static int Modulus(int a, int b) { return a % b; }
		public static long Modulus(long a, long b) { return a % b; }
		public static uint Modulus(uint a, uint b) { return a % b; }
		public static ulong Modulus(ulong a, ulong b) { return a % b; }
		public static double Modulus(double a, double b) { return a % b; }
		public static decimal Modulus(decimal a, decimal b) { return a % b; }

		public static int Multiply(int a, int b) { return a * b; }
		public static long Multiply(long a, long b) { return a * b; }
		public static uint Multiply(uint a, uint b) { return a * b; }
		public static ulong Multiply(ulong a, ulong b) { return a * b; }
		public static double Multiply(double a, double b) { return a * b; }
		public static decimal Multiply(decimal a, decimal b) { return a * b; }

		public static int Subtract(int a, int b) { return a - b; }
		public static long Subtract(long a, long b) { return a - b; }
		public static uint Subtract(uint a, uint b) { return a - b; }
		public static ulong Subtract(ulong a, ulong b) { return a - b; }
		public static double Subtract(double a, double b) { return a - b; }
		public static decimal Subtract(decimal a, decimal b) { return a - b; }

		public static int Add(int a, int b) { return a + b; }
		public static long Add(long a, long b) { return a + b; }
		public static uint Add(uint a, uint b) { return a + b; }
		public static ulong Add(ulong a, ulong b) { return a + b; }
		public static double Add(double a, double b) { return a + b; }
		public static decimal Add(decimal a, decimal b) { return a + b; }

		public static int Divide(int a, int b) { return a / b; }
		public static long Divide(long a, long b) { return a / b; }
		public static uint Divide(uint a, uint b) { return a / b; }
		public static ulong Divide(ulong a, ulong b) { return a / b; }
		public static double Divide(double a, double b) { return a / b; }
		public static decimal Divide(decimal a, decimal b) { return a / b; }

		public static int Ceiling(int x) { return x; }
		public static uint Ceiling(uint x) { return x; }
		public static long Ceiling(long x) { return x; }
		public static ulong Ceiling(ulong x) { return x; }
		public static int Floor(int x) { return x; }
		public static uint Floor(uint x) { return x; }
		public static long Floor(long x) { return x; }
		public static ulong Floor(ulong x) { return x; }
		public static int Round(int x) { return x; }
		public static uint Round(uint  x) { return x; }
		public static long Round(long x) { return x; }
		public static ulong Round(ulong x) { return x; }

		public static double Ceiling(double d) { return Math.Ceiling(d); }
		public static double Floor(double d) { return Math.Floor(d); }
		public static double Round(double d) { return Math.Round(d, 0); }

		public static decimal Ceiling(decimal d) { decimal f = decimal.Floor(d); return f == d ? f : f + 1; }
		public static decimal Floor(decimal d) { return decimal.Floor(d); }
		public static decimal Round(decimal d) { return decimal.Round(d, 0); }
		
		// string functions
		public static string Concat(string a, string b) { return a + b; }
		
		public static string NormalizeSpace(string a)
		{
			string result = "";
			bool needSpace = false;
			for (int i=0; i < a.Length; i++)
			{
				char c = a[i];
				if (c ==' ' || c == '\t' || c == '\n' || c == '\r')
					needSpace = true;
				else
				{
					if (needSpace && result.Length != 0)
						result += ' ';
					result += c;
					needSpace = false;
				}
			}
			return result;
		}

		public static bool StartsWith(string str, string substr)
		{
			return str.StartsWith(substr);
		}

		public static int StringLength(string str)
		{
			return str.Length;
		}

		public static string  Substring(string str, int start, int length)
		{
			int from = start;
			int to = start + length;
			if (from < 1) from = 1;
			if (to > str.Length + 1) to = str.Length + 1;
			if (to <= from) return string.Empty;
			int rfrom = from - 1;
			int rto = to - 1;
			return str.Substring(rfrom, rto - rfrom);
		}

		public static string  Substring(string str, double start, double length)
		{
			double from = start;
			double to = start + length;
			if (from < 1) from = 1;
			if (to > str.Length + 1) to = str.Length + 1;
			if (to <= from) return string.Empty;
			int rfrom = (int)Math.Round(from) - 1;
			int rto = (int)Math.Round(to) - 1;
			if (rto > str.Length) rto = str.Length;
			if (rto <= rfrom) return string.Empty;
			return str.Substring(rfrom, rto - rfrom);
		}

		public static string  Substring(string str, int start, object lengthNull)
		{
			if( --start < 0 ) start = 0;
			return str.Substring(start, str.Length - start);
		}

		public static string  Substring(string str, double start, object lengthNull)
		{
			int istart = (int) start;
			return Substring(str, istart, lengthNull);
		}

		public static string SubstringAfter(string str, string substr)
		{
			int position = str.IndexOf( substr);
			if( position >= 0 )
				return (str.Substring(position + substr.Length));
			else
				return "";
		}

		public static string SubstringBefore(string str, string substr)
		{
			int position = str.IndexOf(substr);
			if( position >= 0 )
				return str.Substring(0, position);
			else
				return "";
		}

		public static string Translate(string a, string b, string c)
		{
			string result = "";
			for (int i=0; i< a.Length; i++)
			{
				char ai = a[i];
				int off = b.IndexOf(ai);
				if (off != -1 && off < c.Length)
					result += c[off];
				else if (off == -1)
					result += ai;
			}
			return result;
		}

		public static bool Contains(string str, string substr)
		{
			return str.IndexOf(substr) >= 0;
		}		

		// conversion functions
		public static bool ToBoolean(bool b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(int b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(uint b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(ulong b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(long b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(string b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(double b) { return Altova.CoreTypes.CastToBool(b); }
		public static bool ToBoolean(decimal b) { return Altova.CoreTypes.CastToBool(b); }

		public static decimal ToNumber(bool b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(int b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(uint b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(long b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(ulong b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(double b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(string b) { return Altova.CoreTypes.CastToDecimal(b); }
		public static decimal ToNumber(decimal b) { return Altova.CoreTypes.CastToDecimal(b); }

		public static string ToString(bool b) { return Altova.CoreTypes.CastToString(b); }
		public static string ToString(int b) { return Altova.CoreTypes.CastToString(b); }
		public static string ToString(uint b) { return Altova.CoreTypes.CastToString(b); }
		public static string ToString(long b) { return Altova.CoreTypes.CastToString(b); }
		public static string ToString(ulong b) { return Altova.CoreTypes.CastToString(b); }
		public static string ToString(double b) { return Altova.CoreTypes.CastToString(b); }
		public static string ToString(string b) { return Altova.CoreTypes.CastToString(b); }
		public static string ToString(decimal b) { return Altova.CoreTypes.CastToString(b); }
		public static string ToString(Altova.Types.DateTime dt) { return Altova.CoreTypes.CastToString(dt); }
		public static string ToString(Altova.Types.Duration dt) { return Altova.CoreTypes.CastToString(dt); }
	}
}

//
// Edifact.cs
//
// This file was generated by MapForce 2008r2sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//

using System;
using System.Globalization;
using System.Collections;
using System.Text.RegularExpressions;
using Altova.Types;

namespace Altova.Functions 
{
	public class Edifact
	{

		#region datetime functions
		/// <summary> 
		/// result = datetime + duration
		/// Performs a addition of dates, times and durations.
		/// </summary>
		public static Altova.Types.DateTime ToDate(string sValue, string sFormat) 
		{
			Altova.Types.DateTime result = null;

			int century = 0;
			int year = 0;
			int month = 0;
			int week = 0;
			int day = 0;
			int i = 0;

			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
					// DDMMYY
				case 2:
				{
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day );
				}
					break;

					// MMDDYY
				case 3:
				{
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day );
				}
					break;

					// DDMMCCYY
				case 4:
				{
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day );
				}
					break;


					// CCYYMMB
					// B=1:first half month, B=2:second half month.
				case 6:
				{
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int B	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					Altova.Types.DateTime date = new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, 1 );
					Altova.Types.Duration offset = new Altova.Types.Duration( 0, 0, 15, 0, 0, 0, 0.0, false );
					result = B == 2 ? Lang.DatetimeAdd( date, offset ) : date;
				}
					break;
		
					// CCYYMMW
					// W=1-5 first week to fifth week in a month.
				case 7:
				{
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					week	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					Altova.Types.DateTime baseDate = new Altova.Types.DateTime( Y2KConvert.Year( century, year), month, 1 );
					Altova.Types.Duration days = new Altova.Types.Duration( 0, 0, (week-1) * 7, 0, 0, 0, 0.0, false );
					result	= Lang.DatetimeAdd( baseDate, days );
				}
					break;
		
					// CCYYMMDDS
					// Shift within a calendar day: CC=century YY=year MM=month DD=day S=1-9 shift in a day.
				case 8:
				{
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int s	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day );
				}
					break;
					
					// CCYYMMDDPP
					// Time period within a calendar day: CC=century YY=year MM=month DD=day PP=00-99 time period.
				case 9:
				{
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int pp	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day );
				}
					break;

					// YYMMDD
					// Calendar date: Y = Year; M = Month; D = Day.
				case 101:
				{
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day );
				}
					break;
		
					// CCYYMMDD
					// Calendar date: C = Century ; Y = Year ; M = Month ; D = Day.
				case 102:
				{
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day );
				}
					break;
		
					// YYWWD
					// Calendar week day: Y = Year ; W = Week ; D = Day 
					// Week number 01 is always first week of January 
					// Day number 1 is always Monday.
				case 103:
				{
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					week	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
			
					Altova.Types.DateTime baseDate = new Altova.Types.DateTime( Y2KConvert.Year( year ), 1, 1 ); // 1st Jan.
					Altova.Types.Duration days = new Altova.Types.Duration( 0, 0, (week-1) * 7, 0, 0, 0, 0.0, false );
					Altova.Types.DateTime date = new Altova.Types.DateTime( Lang.DatetimeAdd( baseDate, days ) );
					Altova.Types.Duration oneWeek = new Altova.Types.Duration( 0, 0, 7, 0, 0, 0, 0.0, false );
					int weekNumber = 0;
					
					do
					{
						weekNumber = Lang.Weeknumber( date );
						if( weekNumber < week )
							date = Lang.DatetimeAdd( date, oneWeek );
					}
					while( weekNumber < week );

					Altova.Types.Duration dayOffset = new Altova.Types.Duration( 0, 0, 0, 0, 0, 0, 0.0, false );
					int weekDay = Lang.Weekday( date );
					date = Lang.DatetimeAdd( date, (new Altova.Types.Duration( 0, 0, (weekDay-1), 0, 0, 0, 0.0, true ) ) );
					date = Lang.DatetimeAdd( date, (new Altova.Types.Duration( 0, 0, day-1, 0, 0, 0, 0.0, false ) ) );
					result	= date;
				}
					break;
		
					// YYDDD
					// Calendar day: Y = Year ; D = Day 
					// January the first = Day 001 
					// Always start numbering the days of the year from January 1st through December 31st.
				case 105:
				{
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 3 ) );	i += 3;
					Altova.Types.DateTime baseDate = new Altova.Types.DateTime( Y2KConvert.Year( year ), 1, 1 ); // January 1st 
					Altova.Types.Duration days = new Altova.Types.Duration( 0, 0, day-1, 0, 0, 0, 0.0, false );
					result	= Lang.DatetimeAdd( baseDate, days );
				}
					break;
		
					// MMDD
					// Day of a month: M = Month; D = Day.
				case 106:
				{
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result	= new Altova.Types.DateTime( 1, month, day );
				}
					break;

				default:
				{
				}
					break;
			}
			return result;
		}

		public static Altova.Types.DateTime ToTime(string sValue, string sFormat)
		{
			Altova.Types.DateTime result = null;

			int hour = 0;
			int minute = 0;
			int seconds = 0;
			int i = 0;

			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
				// HHMM
				// Time without seconds: H = Hour; m = Minute.
				case 401:
				{
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( 1, 1, 1, hour, minute, 0.0 );
				}
				break;
	
				// HHMMSS
				// Time with seconds: H = Hour; m = Minute; s = Seconds.
				case 402:
				{
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( 1, 1, 1, hour, minute, seconds );
				}
					break;
		
				// HHMMSSZZZ
				// See 402 plus Z=Time zone.
				case 404:
				{
					string tz;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					tz		= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result = new Altova.Types.DateTime( 1, 1, 1, hour, minute, seconds, TZConvert.Timezone( tz ) );
				}
				break;
		
				// MMMMSS
				// Time without hours: m=minutes, s=seconds.
				case 405:
				{
					minute	= Convert.ToInt32( new String( arrValue, i, 4 ) );	i += 4;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( 1, 1, 1, minute / 60, minute % 60, seconds );
				}
				break;
		
				default:
				{
				}
				break;
			}

			return result;
		}

		public static Altova.Types.DateTime ToDatetime(string sValue, string sFormat)
		{
			Altova.Types.DateTime result = null;

			int century = 0;
			int year = 0;
			int month = 0;
			int day = 0;
			int hour = 0;
			int minute = 0;
			int seconds = 0;
			int i = 0;

			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
					// DDMMCCYYHHMM
				case 5:		
				{
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0 );
				}
				break;

					// CCYYMMDDTHHMM
					// Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; T=Time designator; H=Hour; M=Minutes.
					// The character [T] shall be used as time designator to indicate the start of the representation of the time.
					// For example: 20010912T1433.
				case 10:
				{
					century = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					char T	= Convert.ToChar ( new String( arrValue, i, 1 ) );	i += 1;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0 );
				}
				break;

					// YYMMDDHHMM
					// Calendar date including time without seconds: Y = Year; M = Month; D = Day; H = Hour; M = Minute.
				case 201:
				{
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day, hour, minute, 0 );
				}
					break;

					// YYMMDDHHMMSS
					// Calendar date including time with seconds: Y = Year; M = Month; D = Day; H = Hour; m = Minutes = Seconds.
				case 202:
				{
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day, hour, minute, seconds );
				}
					break;
		
					// CCYYMMDDHHMM
					// Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; H=Hour; M=Minutes.
				case 203:
				{
					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0 );
				}
					break;

					// CCYYMMDDHHMMSS
					// Calendar date including time with seconds: C=Century;Y=Year; M=Month;D=Day;H=Hour;M=Minute;S=Second.
				case 204:
				{
					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, seconds );
				}
					break;

					// CCYYMMDDHHMMZHHMM
					// Calendar date including time and time zone expressed in hours and minutes.
					// ZHHMM = time zone given as offset from Coordinated Universal Time (UTC).
				case 205:
				{
					int offsetH = 0;
					int offsetM = 0;

					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					char s	= Convert.ToChar ( new String( arrValue, i, 1 ) );	i += 1;
					offsetH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					offsetM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int tz  = ( offsetH * 60 + offsetM ) * ((s == '-') ? -1 : +1);
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0, tz );
				}
					break;

					// YYMMDDHHMMZZZ
					// See 201 + Z = Time zone.
				case 301:
				{
					string zone;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					zone	= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day, hour, minute, 0, TZConvert.Timezone( zone ) );
				}
					break;
		
					// YYMMDDHHMMSSZZZ
					// See 202 + Z = Time zone.
				case 302:
				{
					string zone;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					zone	= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( year ), month, day, hour, minute, seconds, TZConvert.Timezone( zone ) );
				}
					break;
		
					// CCYYMMDDHHMMZZZ
					// See 203 plus Z=Time zone.
				case 303:
				{
					string zone;
					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					zone	= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0, TZConvert.Timezone( zone ) );
				}
					break;
		
					// CCYYMMDDHHMMSSZZZ
					// See 204 plus Z=Time zone.
				case 304:
				{
					string zone;
					century	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					year	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					seconds	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					zone	= Convert.ToString( new String( arrValue, i, arrValue.Length - i ) );
					result 	= new Altova.Types.DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, seconds, TZConvert.Timezone( zone ) );
				}
					break;

				default:
				{
				}
				break;
			}
			return result;
		}

		public static Altova.Types.Duration ToDuration(string sValue, string sFormat)
		{
			sValue = sValue.Replace("-", "");
			Altova.Types.Duration result = null;

			int year = 0;
			int month = 0;
			int week = 0;
			int day = 0;
			int hour = 0;
			int minute = 0;
			int seconds = 0;
			int i = 0;

			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
					// MMDDHHMM
					// Month, day, hours, minutes; M = Month; D = Day; H = Hour; M = Minute.
				case 305:
				{
					month	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.Duration( 0, month, day, hour, minute, 0, 0.0, false );
				}
					break;
	
					// DDHHMM
					// Day, hours, minutes; D = Day; H = Hour; M = Minute.
				case 306:
				{	
					day		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.Duration( 0, 0, day, hour, minute, 0, 0.0, false );
				}
					break;

					// ZHHMM
					// Offset from Coordinated Universal Time (UTC) where Z is plus (+) or minus (-).
				case 406:	
				{
					char s	= Convert.ToChar ( new String( arrValue, i, 1 ) );	i += 1;
					hour	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					minute	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result 	= new Altova.Types.Duration( 0, 0, 0, hour, minute, 0, 0.0, s == '-' );
				}
					break;

					// HHMMHHMM
					// Time span without seconds: H = Hour; m = Minute;.
				case 501:
				{
					int fromH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toH		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( 1, 1, 1, fromH, fromM, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( 1, 1, 1, toH, toM, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// HHMMSS-HHMMSS
					// A period of time specified by giving the start time
					// followed by the end time (both expressed by hours
					// minutes and seconds). Data is to be transmitted as
					// consecutive characters without hyphen.
				case 502:	
				{	
					int fromH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromS	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toH		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toS		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( 1, 1, 1, fromH, fromM, fromS );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( 1, 1, 1, toH, toM, toS );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// HHMMSSZZZ-HHMMSSZZZ
					// A period of time specified by giving the start time
					// followed by the end time (both expressed by hours
					// minutes, seconds and time zone). Data is to be
					// transmitted as consecutive characters without hyphen.
				case 503:
				{
					string fromZ, toZ;

					int fromH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromS	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					fromZ		= Convert.ToString(new String( arrValue, i, 3 ) );	i += 3;
					int toH		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toS		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					toZ			= Convert.ToString(new String( arrValue, i, 3 ) );	i += 3;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( 1, 1, 1, fromH, fromM, fromS, TZConvert.Timezone( fromZ ) );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( 1, 1, 1, toH, toM, toS, TZConvert.Timezone( toZ ) );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// YY-YY
					// A period of time specified by giving the start year
					// followed by the end year (both without century). Data is
					// to be transmitted as consecutive characters without
					// hyphen.
				case 701:
				{
					int fromY	= Y2KConvert.Year( Convert.ToInt32( new String( arrValue, i, 2 ) ) );	i += 2;
					int toY		= Y2KConvert.Year( Convert.ToInt32( new String( arrValue, i, 2 ) ) );	i += 2;
					result 		= new Altova.Types.Duration( fromY < toY ? toY-fromY : fromY-toY, 0, 0, 0, 0, 0, 0.0, fromY > toY );
				}
					break;

					// CCYY-CCYY
					// A period of time specified by giving the start year
					// followed by the end year (both including century). Data
					// is to be transmitted as consecutive characters without hyphen.
				case 702:
				{
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2  ) );	i += 2;
					int from	= Y2KConvert.Year( fromC, fromY );
					int to		= Y2KConvert.Year( toC, toY );
					result 		= new Altova.Types.Duration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, from > to );
				}
					break;

					// YYS-YYS
					// A period of time specified by giving the start semester
					// of a year followed by the end semester of a year (both
					// not including century). Data is to be transmitted as
					// consecutive characters without hyphen.
				case 703:
				{
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromS	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toS		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int from	= Y2KConvert.Year( fromY );
					int to		= Y2KConvert.Year( toY );
					// TODO: calculate semester value
					result 		= new Altova.Types.Duration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, from > to );
				}
					break;

					// CCYYS-CCYYS
					// A period of time specified by giving the start semester
					// of a year followed by the end semester of a year (both
					// including century). Data is to be transmitted as
					// consecutive characters without hyphen.
				case 704:	
				{
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromS	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toS		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int from	= Y2KConvert.Year( fromC, fromY );
					int to		= Y2KConvert.Year( toC, toY );
					// TODO: calculate semester value
					result 		= new Altova.Types.Duration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, from > to );
				}
					break;

					// YYPYYP
					// Format of period to be given without hyphen (P = period of 4 months).
				case 705:	
				{
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromP	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toP		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int from	= Y2KConvert.Year( fromY );
					int to		= Y2KConvert.Year( toY );
					// TODO: calculate period value
					result 		= new Altova.Types.Duration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, from > to );
				}
					break;

					// CCYYP-CCYYP
					// Format of period to be given without hyphen (P = period of 4 months).
				case 706:	
				{
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromP	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toP		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int from	= Y2KConvert.Year( fromC, fromY );
					int to		= Y2KConvert.Year( toC, toY );
					// TODO: calculate period value
					result 		= new Altova.Types.Duration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, from > to );
				}
					break;

					// YYQ-YYQ
					// A period of time specified by giving the start quarter
					// of a year followed by the end quarter of year (both not
					// including century). Data is to be transmitted as
					// consecutive characters without hyphen.
				case 707:
				{
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromQ	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toQ		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int from	= Y2KConvert.Year( fromY );
					int to		= Y2KConvert.Year( toY );
					// TODO: calculate quarter value
					result 		= new Altova.Types.Duration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, from > to );
				}
					break;

					// CCYYQ-CCYYQ
					// A period of time specified by giving the start quarter
					// of a year followed by the end quarter of year (both
					// including century). Data is to be transmitted as
					// consecutive characters without hyphen.
				case 708:	
				{
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromQ	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toQ		= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int from	= Y2KConvert.Year( fromC, fromY );
					int to		= Y2KConvert.Year( toC, toY );
					// TODO: calculate quarter value
					result 		= new Altova.Types.Duration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, from > to );
				}
					break;

					// YYMM-YYMM
					// A period of time specified by giving the start month of
					// a year followed by the end month of a year (both not
					// including century). Data is to be transmitted as
					// consecutive characters without hyphen.
				case 709:
				{
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromY ), fromM, 1, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toY ), toM, 1, 0, 0, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// CCYYMM-CCYYMM
					// A period of time specified by giving the start month of
					// a year followed by the end month of a year (both
					// including century). Data is to be transmitted as
					// consecutive characters without hyphen.
				case 710:
				{
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromC, fromY ), fromM, 1, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toC, toY ), toM, 1, 0, 0, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// CCYYMMDD-CCYYMMDD
					// Format of period to be given in actual message without
					// hyphen.
					// Note: 
					// 1. This code value will be removed effective with
					// directory D.03B.
				case 711:
				{
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toC, toY ), toM, toD, 0, 0, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// YYMMDDHHMM-YYMMDDHHMM
					// A period of time specified by giving the start time
					// followed by the end time (format year, month, day, hour
					// and minute). Data is to be transmitted as consecutive
					// characters without hyphen.
				case 713:
				{
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromY ), fromM, fromD, fromTH, fromTM, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toY ), toM, toD, toTH, toTM, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// YYWW-YYWW
					// A period of time specified by giving the start week of a
					// year followed by the end week of year (both not
					// including century). Data is to be transmitted as
					// consecutive characters without hyphen.
				case 715:
				{
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromW	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toW		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;

					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromY ), 1, 1, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toY ), 1, 1, 0, 0, 0 );
					from		= Lang.DatetimeAdd( from, new Altova.Types.Duration(0, 0, 7 * fromW, 0, 0, 0, 0.0, false) );
					to			= Lang.DatetimeAdd( to,   new Altova.Types.Duration(0, 0, 7 * toW,   0, 0, 0, 0.0, false) );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// CCYYWW-CCYYWW
					// A period of time specified by giving the start week of a
					// year followed by the end week of year (both including
					// century). Data is to be transmitted as consecutive
					// characters without hyphen.
				case 716:
				{
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromW	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toW		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;

					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromC, fromY ), 1, 1, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toC, toY ), 1, 1, 0, 0, 0 );
					from		= Lang.DatetimeAdd( from, new Altova.Types.Duration(0, 0, 7 * fromW, 0, 0, 0, 0.0, false) );
					to			= Lang.DatetimeAdd( to,   new Altova.Types.Duration(0, 0, 7 * toW,   0, 0, 0, 0.0, false) );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// YYMMDD-YYMMDD
					// A period of time specified by giving the start date
					// followed by the end date (both not including century).
					// Data is to be transmitted as consecutive characters
					// without hyphen.
				case 717:
				{
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromY ), fromM, fromD, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toY ), toM, toD, 0, 0, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// CCYYMMDD-CCYYMMDD
					// A period of time specified by giving the start date
					// followed by the end date (both including century). Data
					// is to be transmitted as consecutive characters without
					// hyphen.
				case 718:
				{
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, 0, 0, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toC, toY ), toM, toD, 0, 0, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// CCYYMMDDHHMM-CCYYMMDDHHMM
					// A period of time which includes the century, year,
					// month, day, hour and minute. Format of period to be
					// given in actual message without hyphen.
				case 719:
				{
					int fromC	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromY	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromD	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toC		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toY		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toM		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toD		= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					Altova.Types.DateTime from	= new Altova.Types.DateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, fromTH, fromTM, 0 );
					Altova.Types.DateTime to	= new Altova.Types.DateTime( Y2KConvert.Year( toC, toY ), toM, toD, toTH, toTM, 0 );
					result		= Lang.DatetimeDiff( to, from );
				}
					break;

					// DHHMM-DHHMM
					// Format of period to be given without hyphen (D=day of
					// the week, 1=Monday; 2=Tuesday; ... 7=Sunday).
				case 720:
				{
					int fromDOW	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int fromTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int fromTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toDOW	= Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					int toTH	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int toTM	= Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					
					fromDOW = ( fromDOW % 7 ) + 1;
					toDOW	= ( toDOW % 7 ) + 1;

					Altova.Types.DateTime from = new Altova.Types.DateTime(1, 1, 1, fromTH, fromTM, 0.0 );
					Altova.Types.Duration oneday = new Altova.Types.Duration( 0, 0, 1, 0, 0, 0, 0.0, false );
					while( Lang.Weekday( from ) != fromDOW )
						from = Lang.DatetimeAdd( from, oneday );
					
					Altova.Types.DateTime to = new Altova.Types.DateTime( from.Value.Year, from.Value.Month, from.Value.Day, toTH, toTM, 0 );
					while( Lang.Weekday( to ) != toDOW )
						to = Lang.DatetimeAdd( to, oneday );
					
					result = Lang.DatetimeDiff( to, from );
				}
					break;

					// Year
					// To indicate a quantity of years.
				case 801:
				{
					year = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( year, 0, 0, 0, 0, 0, 0.0, false );
				}
					break;

					// Month
					// To indicate a quantity of months.
				case 802:
				{
					month = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, month, 0, 0, 0, 0, 0.0, false );
				}
					break;

					// Week
					// To indicate a quantity of weeks.
				case 803:
				{
					week = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, week * 7, 0, 0, 0, 0.0, false );
				}
					break;

					// Day
					// To indicate a quantity of days.
				case 804:
				{
					day = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, day, 0, 0, 0, 0.0, false );
				}
					break;

					// Hour
					// To indicate a quantity of hours.
				case 805:
				{
					hour = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, 0, hour, 0, 0, 0.0, false );
				}
					break;

					// Minute
					// To indicate a quantity of minutes.
				case 806:
				{
					minute = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, 0, 0, minute, 0, 0.0, false );
				}
					break;

					// Second
					// To indicate a quantity of seconds.
				case 807:
				{
					seconds = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, 0, 0, 0, seconds, 0.0, false );
				}
					break;

					// Semester
					// To indicate a quantity of semesters (six months).
				case 808:
				{
					int semester = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, semester * 6, 0, 0, 0, 0, 0.0, false );
				}
					break;

					// Four months period
					// To indicate a quantity of four months periods.
				case 809:
				{
					int fourMonth = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, fourMonth * 4, 0, 0, 0, 0, 0.0, false );
				}
					break;
		
					// Trimester
					// To indicate a quantity of trimesters (three months).
				case 810:
				{
					int trimester = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, trimester * 3, 0, 0, 0, 0, 0.0, false );
				}
					break;
		
					// Half month
					// To indicate a quantity of half months.
				case 811:
				{
					int halfMonth = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, halfMonth * 15, 0, 0, 0, 0.0, false );
				}
					break;
		
					// Ten days
					// To indicate a quantity of ten days periods.
				case 812:
				{
					int tenDays = Convert.ToInt32( sValue );
					result = new Altova.Types.Duration( 0, 0, tenDays * 10, 0, 0, 0, 0.0, false );
				}
					break;
		
				default:
				{
				}
					break;
			}

			return result;
		}

		public static string Autoformat(string sValue, string sFormat)
		{
			string result = null;

			int i = 0;
			char[] arrValue = sValue.ToCharArray();

			switch( Convert.ToInt64(sFormat) )
			{
					// DDD
					// Day's number within a specific year: D = Day.
				case 107:
				{
					// Note: gDay cannot accommodate all values. So we return a days-duration.
					int number = Convert.ToInt32( sValue );
					if( number >= 0 )
						result = "P" + number.ToString() + "D";
					else
						result = "-P" + (-number).ToString() + "D";
				}
					break;

					// WW
					// Week's number within a specific year: W = Week.
				case 108:	
				{
					// Note: A 'gWeek' does not exist and gDay cannot accommodate all values. So we return a days-duration.
					int number = Convert.ToInt32( sValue );
					if( number >= 0 )
						result = "P" + (number * 7).ToString() + "D";
					else
						result = "-P" + (-number * 7).ToString() + "D";
				}
					break;

					// MM
					// Month's number within a specific year: M = Month.
				case 109:
				{
					// gMonth
					int number = Convert.ToInt32( sValue );
					result = "--" + number.ToString("00");
				}
					break;

					// DD
					// Day's number within is a specific month: D = Day.
				case 110:
				{		
					// gDay
					int number = Convert.ToInt32( sValue );
					result = "---" + number.ToString("00");
				}
					break;

					// CC
					// Century.
				case 600:
				{
					// gYear
					int number = Convert.ToInt32( sValue );
					result = number.ToString("00") + "00";
				}
					break;

					// YY
					// Calendar year: Y = Year.
				case 601:
				{
					// gYear
					int number = Y2KConvert.Year( Convert.ToInt32( sValue ) );
					result = number.ToString("0000");
				}
					break;

					// CCYY
					// Calendar year including century: C = Century; Y = Year.
				case 602:
				{
					// gYear
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int number = Y2KConvert.Year( cc, yy );
					result = number.ToString("0000");
				}
					break;

					// YYS
					// Semester in a calendar year: Y = Year; S = Semester.
				case 603:	
				{
					// gYearMonth
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int s  = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					result = Y2KConvert.Year( yy ).ToString("0000") + "-" + ((s - 1) * 6 + 1).ToString("00");
				}
					break;

					// CCYYS
					// Semester in a calendar year: C = Century; Y = Year; S = Semester.
				case 604:
				{
					// gYearMonth
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int s  = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					result = Y2KConvert.Year( cc, yy ).ToString("0000") + "-" + ((s - 1) * 6 + 1).ToString("00");
				}
					break;

					// CCYYQ
					// Quarter in a calendar year: C = Century; Y = Year; Q = Quarter.
				case 608:	
				{
					// gYearMonth
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int q  = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					result = Y2KConvert.Year( cc, yy ).ToString("0000") + "-" + ((q - 1) * 4 + 1).ToString("00");
				}
					break;

					// YYMM
					// Month within a calendar year: Y = Year; M = Month.
				case 609:
				{
					// gYearMonth
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int mm = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result = Y2KConvert.Year( yy ).ToString("0000") + "-" + mm.ToString("00");
				}
					break;

					// CCYYMM
					// Month within a calendar year: CC = Century; Y = Year; M = Month.
				case 610:
				{
					// gYearMonth
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int mm = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					result = Y2KConvert.Year( cc, yy ).ToString("0000") + "-" + mm.ToString("00");
				}
					break;

					// YYMMA
					// To specifiy a ten-day period within a month of a year (A = ten day period).
				case 613:
				{
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int mm = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int a  = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					Altova.Types.DateTime date = new Altova.Types.DateTime( Y2KConvert.Year( yy ), mm, 1 );
					Altova.Types.Duration dur = new Altova.Types.Duration( 0, 0, (a - 1) * 10, 0, 0, 0, 0.0, false );
					date = Lang.DatetimeAdd( date, dur );
					result = date.ToString(Altova.Types.DateTimeFormat.W3_date);
				}
					break;

					// CCYYMMA
					// To specifiy a ten-day period within a month of a year, including century  (A = ten day period).
				case 614:
				{
					int cc = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int yy = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int mm = Convert.ToInt32( new String( arrValue, i, 2 ) );	i += 2;
					int a  = Convert.ToInt32( new String( arrValue, i, 1 ) );	i += 1;
					Altova.Types.DateTime date = new Altova.Types.DateTime( Y2KConvert.Year( cc, yy ), mm, 1 );
					Altova.Types.Duration dur = new Altova.Types.Duration( 0, 0, (a - 1) * 10, 0, 0, 0, 0.0, false );
					date = Lang.DatetimeAdd( date, dur );
					result = date.ToString(Altova.Types.DateTimeFormat.W3_date);
				}
					break;

					// Day of the week
					// Numeric representation of the day (Monday = 1).
				case 813:
				{
					int number = Convert.ToInt32( sValue );
					result = "---" + number.ToString();
				}
					break;

					// Working days
					// Number of working days.
				case 814:
				{
					int number = Convert.ToInt32( sValue );
					if( number >= 0 )
						result = "P" + number.ToString() + "D";
					else
						result = "-P" + (-number).ToString() + "D";
				}
					break;

				default:
				{
					Altova.Types.DateTime time = Edifact.ToTime( sValue, sFormat );
					if( time != null ) return time.ToString( Altova.Types.DateTimeFormat.W3_time );

					Altova.Types.DateTime date = Edifact.ToDate( sValue, sFormat );
					if( date != null ) return date.ToString( Altova.Types.DateTimeFormat.W3_date );

					Altova.Types.DateTime datetime = Edifact.ToDatetime( sValue, sFormat );
					if( datetime != null ) return datetime.ToString();

					Altova.Types.Duration duration = Edifact.ToDuration( sValue, sFormat );
					if( duration != null ) return duration.ToString();

					result = sValue;
				}
					break;
			}

			return result;
		}

		#endregion // datetime functions


		#region helpers
			
		class Y2KConvert
		{
			public static int Year( int nYear )
			{
				return nYear > 50 ? 1900 + nYear : 2000 + nYear;
			}

			public static int Year( int nCentury, int nYear )
			{
				return (nCentury * 100) + nYear;
			}

		}

		class TZConvert
		{

			struct TimeZoneData
			{
				public string	sName;
				public float	dOffset;

				public TimeZoneData( string name, float offset )
				{
					sName = name;
					dOffset = offset;
				}			
			}

			static TimeZoneData[] arrAbb = 
			{
				new TimeZoneData("NST",+12.0f),	/* Pacific/Auckland */
				new TimeZoneData("SST",+11.0f),	/* Pacific/Guadalcanal */
				new TimeZoneData("AET",+10.0f),	/* Australia/Sydney */
				new TimeZoneData("ACT", +9.5f),	/* Australia/Darwin */
				new TimeZoneData("JST", +9.0f),	/* Asia/Tokyo */
				new TimeZoneData("CTT", +8.0f),	/* Asia/Shanghai */
				new TimeZoneData("VST", +7.0f),	/* Asia/Saigon */
				new TimeZoneData("BST", +6.0f),	/* Asia/Dacca */
				new TimeZoneData("IST", +5.5f),	/* Asia/Calcutta */
				new TimeZoneData("PLT", +5.0f),	/* Asia/Karachi */
				new TimeZoneData("NET", +4.0f),	/* Asia/Yerevan */
				new TimeZoneData("MET", +3.5f),	/* Asia/Tehran */
				new TimeZoneData("EAT", +3.0f),	/* Africa/Addis_Ababa */
				new TimeZoneData("EET", +2.0f),	/* Europe/Istanbul */
				new TimeZoneData("ART", +2.0f),	/* Africa/Cairo */
				new TimeZoneData("CAT", +2.0f),	/* Africa/Harare */
				new TimeZoneData("ECT", +1.0f),	/* Europe/Paris */
				new TimeZoneData("CET", +1.0f),	/* Europe/Paris */
				new TimeZoneData("GMT",  0.0f),	/* GMT */
				new TimeZoneData("UT",   0.0f),	/* GMT */
				new TimeZoneData("UTC",  0.0f),	/* GMT */
				new TimeZoneData("BET", -3.0f),	/* America/Sao_Paulo */
				new TimeZoneData("AGT", -3.0f),	/* America/Buenos_Aires */
				new TimeZoneData("CNT", -3.5f),	/* America/St_Johns */
				new TimeZoneData("PRT", -5.0f),	/* America/Puerto_Rico */
				new TimeZoneData("EST", -5.0f),	/* America/New_York */
				new TimeZoneData("IET", -5.0f),	/* America/Indianapolis */
				new TimeZoneData("CST", -6.0f),	/* America/Chicago */
				new TimeZoneData("MST", -7.0f),	/* America/Denver */
				new TimeZoneData("PNT", -7.0f),	/* America/Phoenix */
				new TimeZoneData("PST", -8.0f),	/* America/Los_Angeles */
				new TimeZoneData("MDT", -8.0f),	/* America/Boise */			/* Mountain Standard Time */
				new TimeZoneData("AST", -9.0f),	/* America/Anchorage */
				new TimeZoneData("PDT", -9.0f),	/* America/Dawson */		/* Pacific Standard Time */
				new TimeZoneData("HST",-10.0f),	/* Pacific/Honolulu */
				new TimeZoneData("TKT",-10.0f),	/* Pacific/Fakaofo */		/* Tokelau Time */
				new TimeZoneData("CKT",-10.0f),	/* Pacific/Rarotonga */		/* Cook Is. Time */
				new TimeZoneData("MIT",-11.0f),	/* Pacific/Apia */
				new TimeZoneData("WST",-11.0f),	/* Pacific/Apia */
				new TimeZoneData("SST",-11.0f),	/* Pacific/Midway */		/* Samoa Standard Time */
				new TimeZoneData("NUT",-11.0f),	/* Pacific/Niue */			/* Niue Time */
			};

			static TimeZoneData[] arrMil = 
			{
				new TimeZoneData("Z", 0.0f), // Zulu Time ( UTC )
				new TimeZoneData("A", +1.0f), new TimeZoneData("B", +2.0f), new TimeZoneData("C", +3.0f), new TimeZoneData("D", +4.0f), new TimeZoneData("E", +5.0f), new TimeZoneData("F", +6.0f), new TimeZoneData("G", +7.0f), new TimeZoneData("H", +8.0f), new TimeZoneData("I", +9.0f), new TimeZoneData("K", +10.0f), new TimeZoneData("L", +11.0f), new TimeZoneData("M", +12.0f),
				new TimeZoneData("N", -1.0f), new TimeZoneData("O", -2.0f), new TimeZoneData("P", -3.0f), new TimeZoneData("Q", -4.0f), new TimeZoneData("R", -5.0f), new TimeZoneData("S", -6.0f), new TimeZoneData("T", -7.0f), new TimeZoneData("U", -8.0f), new TimeZoneData("V", -9.0f), new TimeZoneData("W", -10.0f), new TimeZoneData("X", -11.0f), new TimeZoneData("Y", -12.0f), 
			};

			public static int Timezone( string sTimezone )
			{
				// Input Parameter:
				// coded tz value like "GMT", "Z" or "+10"
				// Return Value:
				// the corresponding timezone offset in MINUTES!
				// when the tz couldn't be found the return value is 0.
				// Possible formats for Timezone resolution:
				// - Hour offset from GMT (+/-HH)
				// - Three letter timezone code
				// - One letter millitary code (Z=UTC)


				// Pass 1: 
				// check the length of the input string.
				// For single letter lookup the timezone offset from the tzMil array.
				if( sTimezone.Length == 1 )
				{
					foreach( TimeZoneData data in arrMil )
						if( sTimezone == data.sName ) 
							return (int)( 60 * data.dOffset );
				}
				else		
				{
					// Pass 2: 
					// lookup the timezone offset from tzAbb array
					// all standard timezones and the offsets are recorded
					foreach( TimeZoneData data in arrAbb )
						if( sTimezone == data.sName ) 
							return (int)( 60 * data.dOffset );

					// Pass 3: 
					// try to extract the +/-HH format
					int nHours = Convert.ToInt32( sTimezone );
					return 60 * nHours;
				}
				return 0;
			}	
		}

		#endregion // helpers

	}
}
